156a157
>       Set<String> validProperties = Sets.newHashSet();
171a173,189
> 
>           // NOTE(nicksantos): This pass's object-splitting algorithm has
>           // a blind spot. It assumes that if a property isn't defined on an
>           // object, then the value is undefined. This is not true, because
>           // Object.prototype can have arbitrary properties on it.
>           //
>           // We short-circuit this problem by bailing out if we see a reference
>           // to a property that isn't defined on the object literal. This
>           // isn't a perfect algorithm, but it should catch most cases.
>           String propName = parent.getLastChild().getString();
>           if (!validProperties.contains(propName)) {
>             if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {
>               validProperties.add(propName);
>             } else {
>               return false;
>             }
>           }
205a224,226
> 
>           validProperties.add(child.getString());
> 

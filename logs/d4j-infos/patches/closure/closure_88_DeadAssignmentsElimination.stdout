296c296
<           VariableLiveness state = readVariableBeforeKilling(sibling, variable);
---
>           VariableLiveness state = isVariableReadBeforeKill(sibling, variable);
319,320c319,320
<    * Give an expression and a variable. It returns READ, if the right-most
<    * reference of that variable is a read. It returns KILL, if the right-most
---
>    * Give an expression and a variable. It returns READ, if the first
>    * reference of that variable is a read. It returns KILL, if the first
322,324d321
<    *
<    * This need to be a pre-order traversal so we cannot use the normal node
<    * traversals.
326c323,324
<   private VariableLiveness readVariableBeforeKilling(Node n, String variable) {
---
>   private VariableLiveness isVariableReadBeforeKill(
>       Node n, String variable) {
328a327,335
>         Preconditions.checkState(n.getParent().getType() == Token.ASSIGN);
>         // The expression to which the assignment is made is evaluated before
>         // the RHS is evaluated (normal left to right evaluation) but the KILL
>         // occurs after the RHS is evaluated.
>         Node rhs = n.getNext();
>         VariableLiveness state = isVariableReadBeforeKill(rhs, variable);
>         if (state == VariableLiveness.READ) {
>           return state;
>         }
333a341,342
> 
>     // Expressions are evaluated left-right, depth first.
336,337c345,346
<       if (!ControlFlowGraph.isEnteringNewCfgNode(child)) {
<         VariableLiveness state = readVariableBeforeKilling(child, variable);
---
>       if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION
>         VariableLiveness state = isVariableReadBeforeKill(child, variable);

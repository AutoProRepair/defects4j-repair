1354a1355,1359
>     // Track the start of the line to count whitespace that
>     // the tokenizer skipped. Because this case is rare, it's easier
>     // to do this here than in the tokenizer.
>     int lineStartChar = -1;
> 
1358c1363,1367
<           if (!ignoreStar) {
---
>           if (ignoreStar) {
>             // Mark the position after the star as the new start of the line.
>             lineStartChar = stream.getCharno() + 1;
>           } else {
>             // The star is part of the comment.
1374a1384
>           lineStartChar = 0;
1378,1380c1388,1407
<         case ANNOTATION:
<         case EOC:
<         case EOF:
---
>         default:
>           ignoreStar = false;
>           state = State.SEARCHING_ANNOTATION;
> 
>           boolean isEOC = token == JsDocToken.EOC;
>           if (!isEOC) {
>             if (lineStartChar != -1 && option == WhitespaceOption.PRESERVE) {
>               int numSpaces = stream.getCharno() - lineStartChar;
>               for (int i = 0; i < numSpaces; i++) {
>                 builder.append(' ');
>               }
>               lineStartChar = -1;
>             } else if (builder.length() > 0) {
>               // All tokens must be separated by a space.
>               builder.append(' ');
>             }
>           }
> 
>           if (token == JsDocToken.EOC ||
>               token == JsDocToken.EOF ||
1383,1384c1410,1411
<           if (!(option == WhitespaceOption.PRESERVE &&
<                 token == JsDocToken.ANNOTATION)) {
---
>               (token == JsDocToken.ANNOTATION &&
>                option != WhitespaceOption.PRESERVE)) {
1402,1411d1428
<           // FALL THROUGH
< 
<         default:
<           ignoreStar = false;
<           state = State.SEARCHING_ANNOTATION;
< 
<           if (builder.length() > 0) {
<             builder.append(' ');
<           }
< 

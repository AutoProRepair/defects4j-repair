190a191,210
>                     if (ga * gb > 0) {
>                         // this is a corner case:
>                         // - there was an event near ta,
>                         // - there is another event between ta and tb
>                         // - when ta was computed, convergence was reached on the "wrong side" of the interval
>                         // this implies that the real sign of ga is the same as gb, so we need to slightly
>                         // shift ta to make sure ga and gb get opposite signs and the solver won't complain
>                         // about bracketing
>                         final double epsilon = (forward ? 0.25 : -0.25) * convergence;
>                         for (int k = 0; (k < 4) && (ga * gb > 0); ++k) {
>                             ta += epsilon;
>                             interpolator.setInterpolatedTime(ta);
>                             ga = handler.g(ta, interpolator.getInterpolatedState());
>                         }
>                         if (ga * gb > 0) {
>                             // this should never happen
>                             throw MathRuntimeException.createInternalError(null);
>                         }
>                     }
>                          
209,218c229,231
<                     double root;
<                     try {
<                         root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);
<                     } catch (IllegalArgumentException iae) {
<                         // the interval did not really bracket a root
<                         root = Double.NaN;
<                     }
<                     if (Double.isNaN(root) ||
<                         ((Math.abs(root - ta) <= convergence) &&
<                          (Math.abs(root - previousEventTime) <= convergence))) {
---
>                     final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);
>                     if ((Math.abs(root - ta) <= convergence) &&
>                          (Math.abs(root - previousEventTime) <= convergence)) {

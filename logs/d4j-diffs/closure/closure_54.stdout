com.google.javascript.rhino.jstype.FunctionType

341d340
<         baseType.isUnknownType() ||
366c365,367
<     boolean replacedPrototype = prototype != null;
---
>     PrototypeObjectType oldPrototype = this.prototype;
>     boolean replacedPrototype = oldPrototype != null;
> 
370a372,377
>     if (oldPrototype != null) {
>       // Disassociating the old prototype makes this easier to debug--
>       // we don't have to worry about two prototypes running around.
>       oldPrototype.setOwnerFunction(null);
>     }
> 


com.google.javascript.jscomp.TypedScopeCreator

1381,1398d1380
<       // Function prototypes are special.
<       // It's a common JS idiom to do:
<       // F.prototype = { ... };
<       // So if F does not have an explicitly declared super type,
<       // allow F.prototype to be redefined arbitrarily.
<       if ("prototype".equals(propName)) {
<         Var qVar = scope.getVar(qName);
<         if (qVar != null) {
<           if (!qVar.isTypeInferred()) {
<             // Just ignore assigns to declared prototypes.
<             return;
<           }
<           if (qVar.getScope() == scope) {
<             scope.undeclare(qVar);
<           }
<         }
<       }
< 
1417a1400,1431
>       // Function prototypes are special.
>       // It's a common JS idiom to do:
>       // F.prototype = { ... };
>       // So if F does not have an explicitly declared super type,
>       // allow F.prototype to be redefined arbitrarily.
>       if ("prototype".equals(propName)) {
>         Var qVar = scope.getVar(qName);
>         if (qVar != null) {
>           // If the programmer has declared that F inherits from Super,
>           // and they assign F.prototype to an object literal,
>           // then they are responsible for making sure that the object literal's
>           // implicit prototype is set up appropriately. We just obey
>           // the @extends tag.
>           ObjectType qVarType = ObjectType.cast(qVar.getType());
>           if (qVarType != null &&
>               rhsValue != null &&
>               rhsValue.getType() == Token.OBJECTLIT) {
>             typeRegistry.resetImplicitPrototype(
>                 rhsValue.getJSType(), qVarType.getImplicitPrototype());
>           } else if (!qVar.isTypeInferred()) {
>             // If the programmer has declared that F inherits from Super,
>             // and they assign F.prototype to some arbitrary expression,
>             // there's not much we can do. We just ignore the expression,
>             // and hope they've annotated their code in a way to tell us
>             // what props are going to be on that prototype.
>             return;
>           }
>           if (qVar.getScope() == scope) {
>             scope.undeclare(qVar);
>           }
>         }
>       }


com.google.javascript.rhino.jstype.PrototypeObjectType

590c590
<     Preconditions.checkState(ownerFunction == null);
---
>     Preconditions.checkState(ownerFunction == null || type == null);



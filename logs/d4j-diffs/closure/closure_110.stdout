com.google.javascript.jscomp.ScopedAliases

357a358
>         boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);
366,368c367,371
<         } else if (isVar) {
<           Node value = n.hasChildren() ?
<               v.getInitialValue().detachFromParent() :
---
>         } else if (isVar || isFunctionDecl) {
>           boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);
>           Node grandparent = parent.getParent();
>           Node value = v.getInitialValue() != null ?
>               v.getInitialValue() :
369a373,374
>           Node varNode = null;
> 
377a383,409
>           // First, we need to free up the function expression (EXPR)
>           // to be used in another expression.
>           if (isFunctionDecl) {
>             // Replace "function NAME() { ... }" with "var NAME;".
>             Node existingName = v.getNameNode();
> 
>             // We can't keep the local name on the function expression,
>             // because IE is buggy and will leak the name into the global
>             // scope. This is covered in more detail here:
>             // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf
>             //
>             // This will only cause problems if this is a hoisted, recursive
>             // function, and the programmer is using the hoisting.
>             Node newName = IR.name("").useSourceInfoFrom(existingName);
>             value.replaceChild(existingName, newName);
> 
>             varNode = IR.var(existingName).useSourceInfoFrom(existingName);
>             grandparent.replaceChild(parent, varNode);
>           } else {
>             if (value != null) {
>               // If this is a VAR, we can just detach the expression and
>               // the tree will still be valid.
>               value.detachFromParent();
>             }
>             varNode = parent;
>           }
> 
389c421,426
<             parent.getParent().addChildBefore(newDecl, parent);
---
> 
>             if (isHoisted) {
>               grandparent.addChildToFront(newDecl);
>             } else {
>               grandparent.addChildBefore(newDecl, varNode);
>             }
399c436
<           // Do not allow hoisted functions or other kinds of local symbols.
---
>           // Do not other kinds of local symbols, like catch params.


com.google.javascript.rhino.Node

553a554,557
>     if (n == null) {
>       throw new RuntimeException("node is not a child");
>     }
> 



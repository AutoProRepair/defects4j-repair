com.google.javascript.jscomp.DeadAssignmentsElimination

292a293,319
>       VariableLiveness state = VariableLiveness.MAYBE_LIVE;
>       switch (n.getParent().getType()) {
>         case Token.OR:
>         case Token.AND:
>           // If the currently node is the first child of
>           // AND/OR, be conservative only consider the READs
>           // of the second operand.
>           if (n.getNext() != null) {
>             state = isVariableReadBeforeKill(
>                 n.getNext(), variable);
>             if (state == VariableLiveness.KILL) {
>               state = VariableLiveness.MAYBE_LIVE;
>             }
>           }
>           break;
> 
>         case Token.HOOK:
>           // If current node is the condition, check each following
>           // branch, otherwise it is a conditional branch and the
>           // other branch can be ignored.
>           if (n.getNext() != null && n.getNext().getNext() != null) {
>             state = checkHookBranchReadBeforeKill(
>                 n.getNext(), n.getNext().getNext(), variable);
>           }
>           break;
> 
>         default:
295,296c322,327
<         if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) {
<           VariableLiveness state = isVariableReadBeforeKill(sibling, variable);
---
>             state = isVariableReadBeforeKill(sibling, variable);
>             if (state != VariableLiveness.MAYBE_LIVE) {
>               break;
>             }
>           }
>       }
304,305d334
<         }
<       }
324a354,357
>     if (ControlFlowGraph.isEnteringNewCfgNode(n)) { // Not a FUNCTION
>       return VariableLiveness.MAYBE_LIVE;
>     }
> 
341a375,401
>     switch (n.getType()) {
>       // Conditionals
>       case Token.OR:
>       case Token.AND:
>         VariableLiveness v1 = isVariableReadBeforeKill(
>           n.getFirstChild(), variable);
>         VariableLiveness v2 = isVariableReadBeforeKill(
>           n.getLastChild(), variable);
>         // With a AND/OR the first branch always runs, but the second is
>         // may not.
>         if (v1 != VariableLiveness.MAYBE_LIVE) {
>           return v1;
>         } else if (v2 == VariableLiveness.READ) {
>           return VariableLiveness.READ;
>         } else {
>           return VariableLiveness.MAYBE_LIVE;
>         }
>       case Token.HOOK:
>         VariableLiveness first = isVariableReadBeforeKill(
>             n.getFirstChild(), variable);
>         if (first != VariableLiveness.MAYBE_LIVE) {
>           return first;
>         }
>         return checkHookBranchReadBeforeKill(
>             n.getFirstChild().getNext(), n.getLastChild(), variable);
> 
>       default:
345d404
<       if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION
351a411,428
> 
>     return VariableLiveness.MAYBE_LIVE;
>   }
> 
>   private VariableLiveness checkHookBranchReadBeforeKill(
>       Node trueCase, Node falseCase, String variable) {
>     VariableLiveness v1 = isVariableReadBeforeKill(
>       trueCase, variable);
>     VariableLiveness v2 = isVariableReadBeforeKill(
>       falseCase, variable);
>     // With a hook it is unknown which branch will run, so
>     // we must be conservative.  A read by either is a READ, and
>     // a KILL is only considered if both KILL.
>     if (v1 == VariableLiveness.READ || v2 == VariableLiveness.READ) {
>       return VariableLiveness.READ;
>     } else if (v1 == VariableLiveness.KILL && v2 == VariableLiveness.KILL) {
>       return VariableLiveness.KILL;
>     } else {
353a431
>   }



org.apache.commons.math3.util.ContinuedFraction

124,165c124,129
<         double p0 = 1.0;
<         double p1 = getA(0, x);
<         double q0 = 0.0;
<         double q1 = 1.0;
<         double c = p1 / q1;
<         int n = 0;
<         double relativeError = Double.MAX_VALUE;
<         while (n < maxIterations && relativeError > epsilon) {
<             ++n;
<             double a = getA(n, x);
<             double b = getB(n, x);
<             double p2 = a * p1 + b * p0;
<             double q2 = a * q1 + b * q0;
<             boolean infinite = false;
<             if (Double.isInfinite(p2) || Double.isInfinite(q2)) {
<                 /*
<                  * Need to scale. Try successive powers of the larger of a or b
<                  * up to 5th power. Throw ConvergenceException if one or both
<                  * of p2, q2 still overflow.
<                  */
<                 double scaleFactor = 1d;
<                 double lastScaleFactor = 1d;
<                 final int maxPower = 5;
<                 final double scale = FastMath.max(a,b);
<                 if (scale <= 0) {  // Can't scale
<                     throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,
<                                                    x);
<                 }
<                 infinite = true;
<                 for (int i = 0; i < maxPower; i++) {
<                     lastScaleFactor = scaleFactor;
<                     scaleFactor *= scale;
<                     if (a != 0.0 && a > b) {
<                         p2 = p1 / lastScaleFactor + (b / scaleFactor * p0);
<                         q2 = q1 / lastScaleFactor + (b / scaleFactor * q0);
<                     } else if (b != 0) {
<                         p2 = (a / scaleFactor * p1) + p0 / lastScaleFactor;
<                         q2 = (a / scaleFactor * q1) + q0 / lastScaleFactor;
<                     }
<                     infinite = Double.isInfinite(p2) || Double.isInfinite(q2);
<                     if (!infinite) {
<                         break;
---
>         final double small = 1e-50;
>         double hPrev = getA(0, x);
> 
>         // use the value of small as epsilon criteria for zero checks
>         if (Precision.equals(hPrev, 0.0, small)) {
>             hPrev = small;
166a131,143
> 
>         int n = 1;
>         double dPrev = 0.0;
>         double cPrev = hPrev;
>         double hN = hPrev;
> 
>         while (n < maxIterations) {
>             final double a = getA(n, x);
>             final double b = getB(n, x);
> 
>             double dN = a + b * dPrev;
>             if (Precision.equals(dN, 0.0, small)) {
>                 dN = small;
167a145,147
>             double cN = a + b / cPrev;
>             if (Precision.equals(cN, 0.0, small)) {
>                 cN = small;
170,171c150,154
<             if (infinite) {
<                // Scaling failed
---
>             dN = 1 / dN;
>             final double deltaN = cN * dN;
>             hN = hPrev * deltaN;
> 
>             if (Double.isInfinite(hN)) {
175,178c158
< 
<             double r = p2 / q2;
< 
<             if (Double.isNaN(r)) {
---
>             if (Double.isNaN(hN)) {
182d161
<             relativeError = FastMath.abs(r / c - 1.0);
184,189c163,170
<             // prepare for next iteration
<             c = p2 / q2;
<             p0 = p1;
<             p1 = p2;
<             q0 = q1;
<             q1 = q2;
---
>             if (FastMath.abs(deltaN - 1.0) < epsilon) {
>                 break;
>             }
> 
>             dPrev = dN;
>             cPrev = cN;
>             hPrev = hN;
>             n++;
197c178
<         return c;
---
>         return hN;
198a180
> 



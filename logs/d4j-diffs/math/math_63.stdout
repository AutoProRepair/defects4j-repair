org.apache.commons.math.util.MathUtils

410c410
<      * {@link #equals(double,double,int) this method}.
---
>      * {@link #equals(double,double,int) equals(x, y, 1)}.
415,420d414
<      * @deprecated This method considers that {@code NaN == NaN}. In release
<      * 3.0, the semantics will change in order to comply with IEEE754 where it
<      * is specified that {@code NaN != NaN}.
<      * New methods have been added for those cases wher the old semantics is
<      * useful (see e.g. {@link #equalsIncludingNaN(double,double)
<      * equalsIncludingNaN}.
423c417
<         return (Double.isNaN(x) && Double.isNaN(y)) || x == y;
---
>         return equals(x, y, 1);
1099,1121d1092
<      * Get the next machine representable number after a number, moving
<      * in the direction of another number.
<      * <p>
<      * If <code>direction</code> is greater than or equal to<code>d</code>,
<      * the smallest machine representable number strictly greater than
<      * <code>d</code> is returned; otherwise the largest representable number
<      * strictly less than <code>d</code> is returned.</p>
<      * <p>
<      * If <code>d</code> is NaN or Infinite, it is returned unchanged.</p>
<      *
<      * @param d base number
<      * @param direction (the only important thing is whether
<      * direction is greater or smaller than d)
<      * @return the next machine representable number in the specified direction
<      * @since 1.2
<      * @deprecated as of 2.2, replaced by {@link FastMath#nextAfter(double, double)}
<      */
<     @Deprecated
<     public static double nextAfter(double d, double direction) {
<         return FastMath.nextAfter(d, direction);
<     }
< 
<     /**
1315c1286
<                 unscaled = FastMath.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));
---
>                 unscaled = FastMath.floor(FastMath.nextAfter(unscaled, Double.NEGATIVE_INFINITY));
1317c1288
<                 unscaled = FastMath.ceil(nextAfter(unscaled, Double.POSITIVE_INFINITY));
---
>                 unscaled = FastMath.ceil(FastMath.nextAfter(unscaled, Double.POSITIVE_INFINITY));
1321c1292
<             unscaled = FastMath.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));
---
>             unscaled = FastMath.floor(FastMath.nextAfter(unscaled, Double.NEGATIVE_INFINITY));
1325c1296
<                 unscaled = FastMath.ceil(nextAfter(unscaled, Double.POSITIVE_INFINITY));
---
>                 unscaled = FastMath.ceil(FastMath.nextAfter(unscaled, Double.POSITIVE_INFINITY));
1327c1298
<                 unscaled = FastMath.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));
---
>                 unscaled = FastMath.floor(FastMath.nextAfter(unscaled, Double.NEGATIVE_INFINITY));
1331c1302
<             unscaled = nextAfter(unscaled, Double.NEGATIVE_INFINITY);
---
>             unscaled = FastMath.nextAfter(unscaled, Double.NEGATIVE_INFINITY);
1358c1329
<             unscaled = nextAfter(unscaled, Double.POSITIVE_INFINITY);
---
>             unscaled = FastMath.nextAfter(unscaled, Double.POSITIVE_INFINITY);
1373c1344
<             unscaled = FastMath.ceil(nextAfter(unscaled,  Double.POSITIVE_INFINITY));
---
>             unscaled = FastMath.ceil(FastMath.nextAfter(unscaled,  Double.POSITIVE_INFINITY));
1902,1919d1872
<      * Checks that the given array is sorted.
<      *
<      * @param val Values
<      * @param dir Order direction (-1 for decreasing, 1 for increasing)
<      * @param strict Whether the order should be strict
<      * @throws NonMonotonousSequenceException if the array is not sorted.
<      * @deprecated as of 2.2 (please use the new {@link #checkOrder(double[],OrderDirection,boolean)
<      * checkOrder} method). To be removed in 3.0.
<      */
<     public static void checkOrder(double[] val, int dir, boolean strict) {
<         if (dir > 0) {
<             checkOrder(val, OrderDirection.INCREASING, strict);
<         } else {
<             checkOrder(val, OrderDirection.DECREASING, strict);
<         }
<     }
< 
<     /**



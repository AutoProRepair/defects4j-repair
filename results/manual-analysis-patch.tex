\documentclass{article}

\usepackage{listings}
\newcommand{\mycode}[1]{{\small \texttt{#1}}\xspace}
\usepackage{xspace}
\usepackage{xcolor}
\def\ourif{{\sc if}\xspace}
\newcommand{\todo}[1]{{\color{red}TODO: #1}}


\begin{document}

This informal document presents the manual analysis of patches synthesized with automatic repair.


\subsection{LANG-44} 

The human patch adds a check at the beginning of the method which parses a String to a number (String to int, long, float or double). The string can end with a 'l' , 'f' or a 'd' in order to specify the expected type. If the string only contains the char 'l' which specifies the type 'long' the method returns 0 instead of throws an exception, the others types are already correctly handled.

The patch written by the developer throws an exception if the string contains only one char and this char is not a digit.
%if (val.length() == 1 && !Character.isDigit(val.charAt(0))) {
%    throw new NumberFormatException(val + " is not a valid number.");
%}

The patch generated by Nopol adds a precondition before the method call which parses the string to a long. The method is only executed when the length of the string is bigger than 1. If the condition is not respected the program continues and throws the expected exception.

Correctness: Correct


\subsection{LANG-46}

The human patch adds a parameter to the method, this parameter (\mycode{escapeForwardSlash}) is used to determine if the method has to escape the forward slashes. The method has also an other parameter (\mycode{escapeSingleQuotes}) which is used to determine if the method has to escape simple quotes.

In the test cases, the action of escaping forward slashes is always correlated to the action of escaping simple quotes. 
The generated patches is thus a precondition before the line which escapes forward slashes with \mycode{escapeSingleQuotes} as condition.

Correctness: Incorrect


\subsection{LANG-51}

The buggy method is an utility method which parse a string (no, on, yes, true, false) and returns a boolean. The method contains a switch on the length of the string to parse (\mycode{switch(str.length())}). If the string contains 3 characters (\mycode{case 3}), the method checks if the string begin with 'y' if this condition is not respected then the next case is executed. The human fix consists to add a \mycode{return false} after the if condition. Inside the condition the method compare the two others characters to 'e' and 's'.  

The generated patch replaces the condition by a condition that are always true in this context (\mycode{str != null}). With this patches, the method returns true for each string of 3 characters which ends by "es". None test is written to test this scenario.

Correctness: Incorrect

\subsection{LANG-55}

Problem:
An assignment has to be done only in certain conditions.

Human fix:
The human adds a precondition before the assignment.

Nopol generates a precondition before the buggy assignment. The generated precondition is equivalent to the human patch.

Correctness: Correct


\subsection{LANG-58}
The buggy method which parses a string to a number throws an exception when one integer is followed by 'l'. The 'l' is used to specify the expected type of the output ('l' for long, 'f': float, 'd': double, none: integer).

Human fix:
The human fixes the condition which invalidates the string '1l'

Precondition Nopol  adds an always false precondition before the exception.

Condition Nopol simplifies the condition, remove the buggy part, and relies on checks available in called methods.

Correctness: NopolPC: Incorrect, NopolP: Correct


\subsection{CHART-9} Under specified
Problem: \todo{The buggy method is a method used to update a range of a structure. If the end index of the interval is smaller than the start index, the interval was considered as correct}

The human fix checks if the end index is smaller than the start index then the result is empty.

Nopol generates a patch which does not impact the passing test cases but 
disable a line for all failing test cases. Nopol manages to create a condition that match only the failing test cases that was possible because all failing test cases use a specific amount of data.

Correctness: Incorrect

\subsection{CHART-13}
Problem: The buggy statement contains an instantiation of a range which may contain a negative value.

The human patch checks the issue value if the value is negative, the program uses 0 instead of the negative value. 

The Nopol patch adds an always false precondition before the buggy method call.

Correctness: Incorrect

\subsection{CHART-17} 
Problem: The clone method does not return a perfect clone of the current object.

The human patch uses the clone method of its parent and uses an utility class to copy the other specific data (a list of objects).

Nopol adds a precondition or change the condition before an exception. The precondition or the condition are false only for the failing test cases.

Correctness: Incorrect

\subsection{CHART-21}
Problem: Unknown

The human patch adds a precondition over a major part of the buggy method and create a new method which used to update data.

I don't understand the Nopol patch because the generated precondition is complex and the Nopol patch does not apply on the same file as human patch.

Correctness: Probably incorrect

\subsection{CHART-25}
Problem: The buggy method may throws NullPointerException.

The human patch adds tree not null checks.

The precondition Nopol patch adds a precondition always false before the call of the buggy method

NopolC fix: Unknown but does not change the same file as human patch.

Correctness: Incorrect

\subsection{MATH-32}
Problem: \todo{}

Human fix: Add a not null check

NopolpC fix: unknown

\subsection{MATH-33}
Problem: A if condition contains a method call which uses an incorrect parameter

Human fix: change the incorrect parameter

NopolC fix: replace the method call by a condition which match the data used in the test cases

NopolPC fix: add a precondition before the if with a condition which matches the data used in the test cases

Correctness: Incorrect

\subsection{MATH-41}
Problem: The stop condition and the start position of the for loop is not correct.

Human patch: Change the stop condition and the start position.

NopolPC fix: Add a precondition before the buggy method call. The condition is based on the data used in the passing and failing tests. 

NopolC fix: Change the condition just before the buggy method call. The condition is based on the data used in the passing and failing tests.

Summary: The generated patches are dependent of the data used in the test cases.

Correctness: Incorrect

\subsection{MATH-42}
Problem: A case is not managed when a value equals 0

Human fix: Manages the case when the value is equals to 0

NopolPC adds a precondition before a return null in a method called by the buggy method. 

Summary: Nopol generates a patch that uses variables which are not use in its direct context. The patch is probably incorrect.

Correctness: Unknown but probably incorrect.

\subsection{MATH-57} 

Problem: The multiplication of two integer may produce an integer overflow.

The human patch changes the type to double of the variable which contains the result of the multiplication.

The Nopol patch changes the comportment of the \mycode{equals} method of an other class. With the patch, the method returns always true when the two objects are the same type and have the same length.

Summary: The equals method is not tested

Correctness: Incorrect

\subsection{MATH-58}
Problem: bad parameter in a method call

The human patch removes one parameter of the method call.

The Nopol patch is to complex to be understood. 

The execution path:
test -> buggy method -> call parent class -> call on parent class of an attribute ( constructor parameter) -> call the parent class of the parent class-> call children class -> call the auto fixed method (240 LOC)

Correctness: Probably incorrect

\subsection{MATH-69}
Problem: bad value in array assignment

The human patch changes the assignment value

Summary: I don't see the link between the human fix method and the NopolPC fix method.

Correctness: Unknown

\subsection{MATH-79}
Problem: The arithmetic operations may produce integer overflow.

The human patch uses double instead of integer.

Nopol adds a precondition before the line which may produces an overflow. The precondition ignore all value smaller than -39 and bigger then 42.

Correctness: Incorrect

\subsection{MATH 2}

Problem:
The bug is exposed through an failing assertion.

Human fix:
The fix changes a mathematical formula from method $getNumericalMean$ by including parenthesis for prioritizing the multiplication operation over a division.

GenProg and Kali fixes modify another method w.r.t. the human fix location.
The patch removes an assignment statement that modifies the variable called $upper$. 
The output value of this method depends on this variable.
The removed statements modifies $upper$ using in the right part of the assignment the output of the (buggy) method $getNumericalMean$.
Removing the assignment means the result of the buggy method does not affect other statements.

Correctness: Not correct.
The test cases is quite simple for determining whether the patch is correct or not.

\subsection{MATH 8} 


\begin{figure}[!t]
\centering
%\resizebox{0.5\textwidth}{!}{
\noindent\begin{minipage}{0.4\textwidth}
\begin{lstlisting}[numbers=left]
public T[] sample(int sampleSize) 
throws NotStrictlyPositiveException {
//HUMAN FIX: 
//public Object[] sample(int sampleSize) 
//throws NotStrictlyPositiveException { 
  if (sampleSize <= 0) {
    throw new NotStrictlyPositiveException([...]);
  }
  //HUMAN FIX: final Object[] out = new Object[sampleSize];
  final T[]out = 
  (T[]) Array.newInstance(singletons.get(0).getClass(), sampleSize);

  for (int i = 0; i < sampleSize; i++) {
    out[i] = sample();//The KALI FIX REMOVES THE LINE
  }
  return out;
}
\end{lstlisting}

\end{minipage}
\caption{Code snippet of Bug Math-8. The manually-written patch is shown in the \mycode{Human FIX} comment at Line 2 (change of method declaration) and line 6 (Change variable type. The Fix proposed by Kali consists on removing line 11. }
\end{figure}    
    
    
Bug M8 fails to create an array of random sample from the discrete distribution.
The method sample from class DiscreteDistribution<T> receives the number of random values to generate (sampleSize parameter), and it returns an array of type T[] with that number of random values.
For carry out this functionality, the method first declares a variable  array of type T[] (line Y) and instantiates its using function Array.newInstance(Class<?> componentType, int length) %for creating a new array with the specified component type and dimensions. 
For componentType argument, it takes the class of the first element from the list to sample (field called 'singletons') and for length it passes parameter sampleSize.
%For the type argument, it takes the class of the first element from the list to sample (field called 'singletons'), and for the dimension it passes parameter sampleSize.
Then it assigns a sample  value  (obtained through method DiscreteDistribution.sample() to each array position(line X).

The bug occurs when 
a) the first element is of type T1, an sub-class of T (so, the array instance is of type T1), 
and 
b) one of the samples is an object which is of type T2, an sub-class of T, but not of type T1.
%
%This produces that this object could not be assigned to an array position.
Due to the  incompatibility of types T1 and T2, an ArrayStoreException is thrown when this object is assigned to the array.  


In the Human fix the developer changes  the array's type in its declaration (from T to Object) and the way the array is instantiated.
The patch generated by Kali removes the statement which assigns samples to the array (and that also throws the exception).
As consequence, the result of method sample is an empty array.
The patch produces that the failing test case now passes.
The reason of this is case has only one assertion: it asserts the array size is equal to 1. 
The patch is not correct due the test cases never assert the content of the array.

%https://issues.apache.org/jira/browse/MATH-942




Correctness: Not valid.

\subsection{MATH 40}
Problem:
A loop  reaches the max number of iterations prefixed by the application.
When it happens, the application throws an exception.

The human fix modifies the right part of one variable's assignment. This variable is further used to exit the loop.

GP fix adds an assignment over another variable that also is used for breaking the loop execution.

Correctness: I do not know, the modified code is extremely complex. but it seems invalid.

\subsection{MATH-44}

Problem:
The bug is exposed through a failing assertion.

Human fix:

Before a return statement of the method $acceptStep$ (called inside loop block), 
the patch done by developers adds a method call that modifies the internal state of EventState instances.

GenProg Fix:
Inside the mentioned $acceptStep$ method, the fix changes a boolean field.
This changes forces the later execution of a code block similar to the human fix code (that is, it changes the internal state of instances) in later execution of $acceptStep$ method (remember it is called inside a loop).

Correctness: I do not know. I can be valid. The code is too complex.


\subsection{MATH-49}


Problem:
An exception occurs by trying to modify one vector structure (implemented similar to a map) which, at the same time, it is iterated.
Inside the method for multiplying vectors, an instance of this structure vector is created for store the results of the multiplication, and it is preloaded with one of the vector of the multiplication.
For multiply vectors, the method  iterates the result vector, so, when it tries to set the result there, the mentioned exception is thrown. 

Human fix:
It changes the iterator:  the fix does not iterate the result vector but the term vector of the  multiplication.

GenProg/Kali Fixes:
The fix proposed by GenProg and Kali removes one statement that increments a variable for counting the number of elements of the structure.
The iterator reads this variable to know whether the structure has changed while the iteration. If it changes, the iterator throws an exception.
As the fix removes the incrementation of this variable, the iterator does not realize that the structure receives modification and never throws that exception.

Summary:
The test case does not have any assertion.
So, it assures the not presence of the bug by a) invoking the failing method and b) waiting the exception does not occur. 
However, it does not assess the result of the vector multiplication.

Correctness: Not valid.

\subsection{MATH-50}

Problem:

Human: 
Remove a complete if condition

GenProg-Kali:
Remove one statement (assignment) from a if condition (that one removed by the human patch).

Summary:
Both human and ASTOR patches are the same and correct. 
The test has assertions to validate them.

Correctness: GenProg and Kali valid.

\subsection{MATH-64}
\todo{}


\subsection{MATH-70}

Problem:

The application throws a Null pointer exception.
%A method invocation to incorrect overloaded method.

Fixes:
Both human and GP propose the same fix, that is, to replace a method invocation by a overloaded version.
The $BisectionSolver$ has a field of type $UnivariateRealFunction$ to operate inside the method $solver$. 
The class has two constructors: one that receives an object of type $UnivariateRealFunction$  (and setted in the mentioned field), another without this kind of argument. 
The method solver also is overloaded: one receives a UnivariateRealFunction, the other no.  
The field UnivariateRealFunction is null when the constructor without that argument was called.
The fixes proposed to use the UnivariateRealFunction received as parameter instead of the class field.

Correctness: GenProg patch is valid.

\subsection{MATH-73}

Problem: 
An assertion failing exposes the bug. 
The test case waits for an exception when it calls the method $solve$ with two arguments that represent a "bad inverval".

Human fix:
It adds one if precondition before to check whether the arguments are invalid and, in that case, throws an exception.  
The precondition is added just before calling a overloaded version of $solve$ method.

GP Fix:

Replace the call to 'solve' method by an overloaded version.
The fix method call has less parameters and in its body it has  a similar precondition than the humans fix.
As consequence, the method called by the fix is who detects the invalid arguments.


Correctness: Correct.

\subsection{MATH-78}

Problem:

An assertion fails.
%In the cases the object interpolator "is foward", 
%it missing to modify a value of one variable for adding the value of convergence.


Fix:
Human, Kali and GP have different patches.

The human patch adds a if condition with a large code block inside method $stepAccepted$.
There, it modifies tree fields and method's variables: $ta$, $ga$, and one field from object interpolator.

The GP patch adds an assignment statement in the same method (i.e., stepAccepted), in particular, some statements before the mentioned if added by developers.
the assignment modifies variable $ta$.
The two assignments that modify ta in both human and GenProg patches has a similar right part: the expressions contain access variables to $forward$ and $convergence$.
Regarding to Kali, it removes one assignment from a method $evaluateStep$, that is executed before the mentioned method $stepAccepted$. 
This statements modifies variable 't0' which, then in  $stepAccepted$ method, is assigned to 'ta'.


Correctness: 
Human patch is larger than GenProg and Kali patches (+10 lines vs 1 line).
This patch includes some precondition for detecting illegal states.
The GP is somehow valid. For Kali, I do not know.


\subsection{MATH-80}

Problem:
Assertion failure.

Humans fix:

The method $flipIfWarranted$ flips an array as follows:
The array elements are grouped in rows, for instance, one row the first four elements, the second row the next 4 elements and so on.
The methods aims at flipping the elements inside a row.
The developers have changed the expression that represent the number of rows.

GP removes one of the assignments of the flip method.

Kali removes most of the code for flipping.

The Nopol patch adds a precondition to avoid executing the flip code. This patch has the same effect than Kali's patch.  


Correctness:
Incorrect: GP patches is wrong due to it alternates the array.

I do not know: Kali and Nopol do not modify the array at all. That means is not necessary to flip the array w.r.t. the executed tests.

\subsection{MATH-81}

Problem:
Array index out of bound exception.
The variable b2 is modified with a value of an array element (The variable has a value before that assignment). The test cases exposes an illegal access.

Human fix:
The developers updates the if conditions which block contains the mentioned assignment.
In the commit that includes the fix, the developer also includes other source code changes.


Kali and GP: It removes the assignment statements.

Nopol: Add a precondition to avoid executing the assignment.

Summary:
The test cases seems to not identify the slightly variability in the variable's values due to the assignment removement.

Correctness:
Generated patches are  not corrects. 

\subsection{Math-82}

Problem: 
One test case exposes the bug through a failing assertion.

The class SimpleTableaux has one field that is a double matrix (array of two dimensions).
The method $doIteration$ accesses to this matrix. For that, it calls two methods for obtaining the row and column indexes, respectively.

Human fix: 
It consists on changing a if condition from >= to > into the method for retrieving the row index.

GP, Kali and Nopol modifies the value of the column index. 

Summary:
The automated generated patched version and the human patches generate  different indexes, but by coincidence, the double matrix has the same value on those indexes.

Correctness:
The generated patches are not valid.

\subsection{Math-84}

Problem:
A test cases has two cases that expose a bug:
In one, an assert fails, in the other, it receives an exception.
In both cases, a while reaches the max number of iterations allowed. 

Human patch adds a condition the end of the while block for exit from the while .

GenProg's fix adds a return statement at the end of the while block. 
As consequence, the while iterates only one.

Correctness:
Not valid.

\subsection{Math-85}

Problem:

The test case receives an exception calling to a method.

Human patch: 
The developer changes an if condition by replacing the operator >= for >. The block of this condition throws the mentioned exception.
After the patch, given a set of input values defined in the test case, the if condition is never true, and the exception is never thrown.

Nopol changes the if condition. The patch includes one variable used in the buggy version (fa), and a new one (iterations). This patch is not correct. It has not logic to compare the output of one function with the number of iterations done by the algorithm.

Kali and GenProg patches remove the mentioned if and/or the statement that throws the exception. As consequence, after enter to the if block, the execution remains. 

Summary:

The Generated patches are corrected for the test input, but incorrect for other cases not specific in the test cases. The test case does not include a case for evaluating the detection of a CoverageException.



\subsection{Math-95}

A test case receives a IllegalArgumentException

Human patch: 
The developers modifies a method for always returning positive double values.
A negative value causes an leter Illegal exception.

GenProg replaces the return statement of the method by a $return 0$.

Summary:
The test cases successfully assess the validity of the patched method.
The GenProg patch results (0.9750000000640364) is slightly different from the real patched result (0.9750000261341519), but the test case does not compare at a grade to detect those differences $assertEquals(0.975, x, 1.0e-5);$

\end{document}
